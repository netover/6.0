# Relatório sequencial de bugs, erros e propostas de solução

## Arquivo 001: `analyze_pr_comments.py`

### Bugs/erros encontrados
1. **Tratamento de exceção genérico (`except Exception`) ocultando causa real**
   - Risco: dificulta diagnóstico e mascara erros de tipo/estrutura no JSON.
   - Correção aplicada: substituído por validações explícitas + captura específica de `json.JSONDecodeError`.

2. **Acesso direto a chaves aninhadas (`comment['author']['login']`)**
   - Risco: `KeyError` quando payload vier incompleto.
   - Correção aplicada: adicionado acesso seguro com fallback (`unknown`).

3. **Falta de validação estrutural do JSON carregado**
   - Risco: quebra em runtime caso o conteúdo não seja objeto com listas em `comments/reviews`.
   - Correção aplicada: validação de tipo para raiz do JSON e para os campos `comments` e `reviews`.

4. **Leitura de arquivo sem validação de existência**
   - Risco: stack trace para ausência de `pr_comments.json`.
   - Correção aplicada: verificação antecipada de existência e retorno com código de erro 1.

5. **Script sem função `main` e sem código de saída explícito**
   - Risco: menor testabilidade e ausência de semântica clara de sucesso/erro em CI.
   - Correção aplicada: extraída função `main()` com retorno inteiro e `SystemExit` no bloco `if __name__ == '__main__'`.

6. **`sys.stdout.reconfigure` sem compatibilidade defensiva**
   - Risco: falha em ambientes onde `stdout` não suporta `reconfigure`.
   - Correção aplicada: adicionado helper `_safe_stdout_utf8()` com `hasattr`.

### Resultado
- Script ficou resiliente para payload parcial, erro de estrutura e ausência de arquivo.
- Fluxo de erro/sucesso agora é determinístico para automação.

---

> Próximo arquivo da sequência: pendente.

## Batch 002–101 (análise em lote de 100 arquivos Python)

### Escopo do lote
- Do arquivo `002 apply_fixes_ast.py` até `101 resync/api/routes/system/__init__.py`.
- Método aplicado sem instalação de novas bibliotecas: compilação sintática + varredura estática por padrões de risco comuns.

### Achados do lote
1. **Sem erros de sintaxe no lote (100/100 compilam)**
   - Evidência: execução de `py_compile` para todos os 100 arquivos.
   - Ação: manter.

2. **Uso recorrente de `except Exception` (50 arquivos do lote)**
   - Risco: reduz observabilidade e pode mascarar falhas de lógica/integração.
   - Proposta de correção em ondas:
     - Onda A (alta prioridade): rotas API e middlewares críticos.
     - Onda B: módulos utilitários e scripts.
     - Substituir por exceções específicas por camada (`ValueError`, `KeyError`, `HTTPException`, erros de cliente HTTP/DB etc.).

3. **Uso de `print()` em scripts utilitários (`apply_fixes_ast.py`, `auto_refactor.py`)**
   - Risco: logging inconsistente em execução automatizada.
   - Proposta: migrar para logger estruturado quando esses scripts forem promovidos para pipelines formais.

### Ajustes aplicados no plano CPU-only (dependências)
4. **Torch fixado para wheel CPU via index URL**
   - Correção aplicada em `requirements.txt`:
     - adicionado `--extra-index-url https://download.pytorch.org/whl/cpu`
     - ajustado `torch` para `torch==2.5.1+cpu`
   - Mantidos conforme instrução: `sentence-transformers`, `litellm`, `asyncpg`.

### Próximo lote
- Batch 102–201 (100 arquivos seguintes).

## Correções efetivamente aplicadas (além do relatório)

### Arquivo: `resync/api/middleware/__init__.py`
- Problema: captura genérica em import opcional (`except Exception`) mascarava erros reais do módulo.
- Correção aplicada: captura restrita para `ImportError`, mantendo fail-fast para outros erros de programação.

### Arquivo: `resync/api/routes/core/health.py`
- Problema 1: `HTTPException` era capturada por blocos genéricos em múltiplos endpoints, podendo sobrescrever detalhes de erro intencionais.
- Correção aplicada: adicionado `except HTTPException: raise` antes dos blocos genéricos em endpoints de health/readiness/liveness/recovery/redis.
- Problema 2: repetição de tupla de erros de programação em vários pontos.
- Correção aplicada: extraída constante `PROGRAMMING_ERRORS` para reduzir duplicação e risco de divergência.
- Problema 3: captura redundante de métricas com `except (..., Exception)`.
- Correção aplicada: removida redundância, mantendo captura específica (`AttributeError`, `ImportError`).

### Arquivo: `resync/api/security/__init__.py`
- Problema: `HTTPException` levantada dentro de `decode_token` poderia ser reempacotada pelo `except Exception` final.
- Correção aplicada: adicionado `except HTTPException: raise` para preservar status/detail originais.

## Batch 102–201 (análise em lote de 100 arquivos Python)
- Verificação de compilação sintática: 100/100 arquivos compilam.
- Próxima onda: reduzir `except Exception` em módulos de segurança, rotas system e cache core.

## Batch 202–301 (análise em lote de 100 arquivos Python)

### Correções aplicadas no código (não apenas registro)

1. **`resync/core/database/repositories/base.py`**
   - Problema: `execute_raw()` usava `except Exception` para caminho normal de queries sem result set.
   - Correção: substituído por `except ResourceClosedError` (exceção específica do SQLAlchemy para operações sem linhas de retorno).
   - Ganho: evita mascarar erros reais de programação/SQL ao mesmo tempo em que mantém o comportamento para DML.

2. **`resync/core/database/schema.py`**
   - Problema: criação de schemas e health check de conexão capturavam exceções genéricas.
   - Correção: captura restrita para `SQLAlchemyError` nos dois pontos.
   - Ganho: falhas não relacionadas ao driver/ORM voltam a emergir corretamente.

3. **`resync/core/distributed_tracing.py`**
   - Problema: import opcional de OpenTelemetry capturava `Exception` em bloco global.
   - Correção: troca para `except ImportError`.
   - Ganho: preserva degradação opcional quando pacote não existe, sem suprimir erros internos inesperados.

4. **`resync/core/database/engine.py`**
   - Problema: `close_engine()` capturava `Exception` ao fechar engine.
   - Correção: captura restrita para `SQLAlchemyError`.
   - Ganho: problemas de lógica fora do ciclo de SQLAlchemy não ficam mascarados.

### Validação do lote
- Compilação sintática do batch 202–301: **100/100** arquivos compilam.
- Pendência planejada: reduzir progressivamente os `except Exception` restantes do lote (191 ocorrências) em ondas por criticidade.

## Batch 302–401 (análise em lote de 100 arquivos Python)

### Correções aplicadas no código (não apenas registro)

1. **`resync/core/security/__init__.py`**
   - Bug funcional encontrado: `verify_admin_token()` chamava `decode_token(token)` como se retornasse `(valid, payload)`, mas `decode_token` do módulo unificado exige `secret_key` e retorna payload (dict).
   - Impacto: validação de token admin sempre caía no tratamento de exceção (falso negativo contínuo).
   - Correção aplicada:
     - integração com `get_settings()` para obter `secret_key/jwt_secret_key` e `jwt_algorithm`;
     - chamada correta `decode_token(token, secret_key, algorithms=[algorithm])`;
     - tratamento explícito de erros de token (`JWTError`, `RuntimeError`, `ValueError`) retornando `None` sem mascarar erros de programação.

2. **`resync/core/logging_utils.py`**
   - Problema: redator de dados sensíveis usava `except Exception` durante regex substitution.
   - Correção aplicada: captura restrita para `(ReError, TypeError)`.
   - Ganho: reduz supressão acidental de erros não esperados e mantém robustez para padrões regex inválidos.

### Validação do lote
- Compilação sintática do batch 302–401: **100/100** arquivos compilam.
- Próxima onda: continuar redução de `except Exception` por criticidade em langgraph/observability/pools.

## Batch 402–501 (análise em lote de 100 arquivos Python)

### Correções aplicadas no código (não apenas registro)

1. **`resync/knowledge/retrieval/reranker.py`**
   - Bug de observabilidade: tempo de carregamento do cross-encoder era calculado e descartado; log usava placeholder literal (`{load_time:.0f}`) sem interpolação.
   - Correção aplicada: criação explícita de `load_time` e logging parametrizado (`%.0fms`).
   - Bug de métricas/log: log de rerank usava string literal com chaves (`{original_count}`, etc.) e não reportava valores reais.
   - Correção aplicada: troca para logger parametrizado com variáveis reais (`original_count`, `len(filtered_docs)`, `rerank_time`).

2. **`resync/core/utils/common_error_handlers.py`**
   - Bug de mensagem de retry: textos de backoff eram parcialmente f-string e parcialmente literal, resultando em log com `{current_delay:.2f}` não interpolado.
   - Correção aplicada: ambos os trechos convertidos para f-string completa.
   - Ajuste de consistência: no wrapper assíncrono, mensagem final de falha passa a usar `current_max_retries` (valor efetivo) em vez do default global `max_retries`.

### Validação do lote
- Compilação sintática do batch 402–501: **100/100** arquivos compilam.
- Próxima onda: continuar redução de `except Exception` nos módulos `knowledge/ingestion` e `services/*` com priorização por impacto de runtime.

### Follow-up de correções no Batch 402–501

3. **`resync/knowledge/retrieval/reranker.py` (bug de estado global)**
   - Problema: `get_cross_encoder()` atribuía `_cross_encoder_available = False` em erro de carga, mas sem declarar `global _cross_encoder_available`.
   - Impacto: o estado global de disponibilidade não era atualizado corretamente, podendo forçar tentativas repetidas de carga falha.
   - Correção aplicada: declaração `global _cross_encoder_model, _cross_encoder_available`.

4. **`resync/core/utils/common_error_handlers.py` (inconsistência funcional sync vs async)**
   - Problema: wrapper assíncrono aceitava overrides por chamada (`max_retries`, `initial_backoff`), mas wrapper síncrono ignorava.
   - Impacto: comportamento divergente entre funções sync/async usando o mesmo decorator.
   - Correção aplicada: suporte aos mesmos overrides no wrapper síncrono + uso de `current_max_retries` na mensagem final.
