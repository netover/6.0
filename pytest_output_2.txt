============================= test session starts =============================
platform win32 -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: D:\Python\GITHUB\resync\6.0
plugins: anyio-4.11.0, hypothesis-6.140.2, locust-2.41.2, asyncio-1.2.0, benchmark-5.1.0, cov-7.0.0, mock-3.15.1, timeout-2.4.0, xdist-3.8.0, respx-0.22.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 104 items

resync\tests\contracts\test_tws_client_contract.py .........             [  8%]
resync\tests\test_app_state_contract.py .                                [  9%]
resync\tests\test_database_security.py .F.F.F....F.F...F.F.FF...F....F   [ 39%]
resync\tests\test_database_url_security.py .......                       [ 46%]
resync\tests\test_golden_path_planner.py .......FFF........F............ [ 75%]
..............                                                           [ 89%]
resync\tests\test_http_di_canonical.py .                                 [ 90%]
resync\tests\test_lifespan_smoke.py F                                    [ 91%]
resync\tests\test_migrations_integration.py s                            [ 92%]
resync\tests\test_public_dependency_signatures.py .                      [ 93%]
resync\tests\test_request_scope_isolation.py .F                          [ 95%]
resync\tests\test_startup_timeout.py ...                                 [ 98%]
resync\tests\test_ui_smoke.py FF                                         [100%]

================================== FAILURES ===================================
______ TestDatabaseInputValidator.test_validate_table_name_invalid_cases ______

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A67609A210>

    def test_validate_table_name_invalid_cases(self):
        """Test invalid table names."""
        invalid_cases = [
            ("", "Table name cannot be empty"),
            ("invalid_table", "Table name not in whitelist"),
            ("audit_log; DROP TABLE users; --", "Table name not in whitelist"),
            ("" * 65, "Table name too long"),
            ("audit' OR 1=1 --", "Table name not in whitelist"),
        ]
    
        for table, expected_error in invalid_cases:
            with pytest.raises(DatabaseSecurityError, match=expected_error):
>               DatabaseInputValidator.validate_table_name(table)

resync\tests\test_database_security.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'resync.core.database_security.DatabaseInputValidator'>
table_name = ''

    @classmethod
    def validate_table_name(cls, table_name: str) -> str:
        """
        Validates table name against whitelist to prevent SQL injection.
    
        Args:
            table_name: Table name to validate
    
        Returns:
            Validated table name
    
        Raises:
            DatabaseSecurityError: If table name is invalid
        """
        if not table_name:
>           raise DatabaseSecurityError("Table name cannot be empty")
E           resync.core.database_security.DatabaseSecurityError: Table name cannot be empty

resync\core\database_security.py:88: DatabaseSecurityError

During handling of the above exception, another exception occurred:

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A67609A210>

    def test_validate_table_name_invalid_cases(self):
        """Test invalid table names."""
        invalid_cases = [
            ("", "Table name cannot be empty"),
            ("invalid_table", "Table name not in whitelist"),
            ("audit_log; DROP TABLE users; --", "Table name not in whitelist"),
            ("" * 65, "Table name too long"),
            ("audit' OR 1=1 --", "Table name not in whitelist"),
        ]
    
        for table, expected_error in invalid_cases:
>           with pytest.raises(DatabaseSecurityError, match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AssertionError: Regex pattern did not match.
E            Regex: 'Table name too long'
E            Input: 'Table name cannot be empty'

resync\tests\test_database_security.py:64: AssertionError
_____ TestDatabaseInputValidator.test_validate_column_name_invalid_cases ______

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A676B27490>

    def test_validate_column_name_invalid_cases(self):
        """Test invalid column names."""
        invalid_cases = [
            ("", "Column name cannot be empty"),
            ("invalid_column", "Column name not in whitelist"),
            ("id; DROP TABLE users; --", "Column name not in whitelist"),
            ("" * 65, "Column name too long"),
        ]
    
        for column, expected_error in invalid_cases:
            with pytest.raises(DatabaseSecurityError, match=expected_error):
>               DatabaseInputValidator.validate_column_name(column)

resync\tests\test_database_security.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = <class 'resync.core.database_security.DatabaseInputValidator'>
column_name = ''

    @classmethod
    def validate_column_name(cls, column_name: str) -> str:
        """
        Validates column name against whitelist to prevent SQL injection.
    
        Args:
            column_name: Column name to validate
    
        Returns:
            Validated column name
    
        Raises:
            DatabaseSecurityError: If column name is invalid
        """
        if not column_name:
>           raise DatabaseSecurityError("Column name cannot be empty")
E           resync.core.database_security.DatabaseSecurityError: Column name cannot be empty

resync\core\database_security.py:115: DatabaseSecurityError

During handling of the above exception, another exception occurred:

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A676B27490>

    def test_validate_column_name_invalid_cases(self):
        """Test invalid column names."""
        invalid_cases = [
            ("", "Column name cannot be empty"),
            ("invalid_column", "Column name not in whitelist"),
            ("id; DROP TABLE users; --", "Column name not in whitelist"),
            ("" * 65, "Column name too long"),
        ]
    
        for column, expected_error in invalid_cases:
>           with pytest.raises(DatabaseSecurityError, match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AssertionError: Regex pattern did not match.
E            Regex: 'Column name too long'
E            Input: 'Column name cannot be empty'

resync\tests\test_database_security.py:85: AssertionError
_____ TestDatabaseInputValidator.test_validate_string_input_invalid_cases _____

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A677EB5260>

    def test_validate_string_input_invalid_cases(self):
        """Test invalid string inputs."""
        invalid_cases = [
            (None, "String input cannot be None"),
            (123, "Input must be string"),
            ("" * 10001, "String input too long"),
            ("text with \x00 null byte", "String input cannot contain null bytes"),
            ("'; DROP TABLE users; --", "Dangerous pattern detected"),
            ("' OR '1'='1", "Dangerous pattern detected"),
        ]
    
        for input_text, expected_error in invalid_cases:
>           with pytest.raises(DatabaseSecurityError, match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:113: Failed
____________ TestDatabaseInputValidator.test_sanitize_query_string ____________

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000002A6760E4F50>

    def test_sanitize_query_string(self):
        """Test query string sanitization."""
        test_cases = [
            ("normal query", "normal query"),
            ("query with 'quotes'", "query with ''quotes''"),
            ('query with "quotes"', 'query with ""quotes""'),
            ("query; DROP TABLE users; --", "query DROP TABLE users"),
            ("query with /* comment */ text", "query with comment text"),
        ]
    
        for input_query, expected_output in test_cases:
            result = DatabaseInputValidator.sanitize_query_string(input_query)
>           assert result == expected_output, (
                f"Query sanitization failed: {input_query} -> {result}"
            )
E           AssertionError: Query sanitization failed: query with /* comment */ text -> query with /* comment */ text
E           assert 'query with /...mment */ text' == 'query with comment text'
E             
E             - query with comment text
E             + query with /* comment */ text
E             ?           +++         +++

resync\tests\test_database_security.py:187: AssertionError
__________ TestSecureQueryBuilder.test_build_select_query_with_where __________

self = <resync.tests.test_database_security.TestSecureQueryBuilder object at 0x000002A676BDA0D0>

    def test_build_select_query_with_where(self):
        """Test SELECT query with WHERE clause."""
>       query, params = SecureQueryBuilder.build_select_query(
            table="audit_log", where_clause="status = ?", limit=50
        )

resync\tests\test_database_security.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

table = 'audit_log', columns = None, where_clause = 'status = ?'
order_by = None, limit = 50

    @staticmethod
    def build_select_query(
        table: str,
        columns: list[str] | None = None,
        where_clause: str | None = None,
        order_by: str | None = None,
        limit: int | str | None = None,
    ) -> tuple[str, dict[str, Any]]:
        """
        Builds a secure SELECT query with validation.
    
        Args:
            table: Table name (validated against whitelist)
            columns: List of columns to select (validated against whitelist)
            where_clause: WHERE clause (must be parameterized)
            order_by: ORDER BY clause (validated)
            limit: LIMIT value (validated)
    
        Returns:
            Tuple of (query, parameters)
    
        Raises:
            DatabaseSecurityError: If any component is invalid
        """
        # Validate table name
        validated_table = DatabaseInputValidator.validate_table_name(table)
    
        # Validate columns
        if columns:
            validated_columns = []
            for col in columns:
                validated_columns.append(DatabaseInputValidator.validate_column_name(col))
            columns_str = ", ".join(validated_columns)
        else:
            columns_str = "*"
    
        # Build base query
        query = f"SELECT {columns_str} FROM {validated_table}"
        params = {}
    
        # Add WHERE clause if provided
        if where_clause:
            # Security: WHERE clause MUST use parameterized queries (:param_name).
            # Reject anything that contains subqueries, string literals, or
            # dangerous SQL keywords.  This is defence-in-depth on top of the
            # ORM layer ù callers should ALWAYS pass params separately.
            import re as _re
    
            _SAFE_WHERE = _re.compile(
                r'^[\w.:=<>!%\s,\(\)]+$', _re.ASCII
            )
            if not _SAFE_WHERE.match(where_clause):
>               raise DatabaseSecurityError(
                    "WHERE clause contains disallowed characters. "
                    "Use parameterized queries (:param_name syntax) only."
                )
E               resync.core.database_security.DatabaseSecurityError: WHERE clause contains disallowed characters. Use parameterized queries (:param_name syntax) only.

resync\core\database_security.py:434: DatabaseSecurityError
______ TestSQLInjectionMiddleware.test_sql_injection_detection_patterns _______

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x000002A676BDA710>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_sql_injection_detection_patterns(self, mock_request):
        """Test SQL injection pattern detection."""
        injection_patterns = [
            ("'; DROP TABLE users; --", True),
            ("' OR '1'='1", True),
            ("' UNION SELECT * FROM users --", True),
            ("; EXEC xp_cmdshell('dir') --", True),
            ("'; WAITFOR DELAY '00:00:05' --", True),
            ("' AND 1=CONVERT(int, (SELECT @@version)) --", True),
        ]
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
    
        for injection_attempt, should_detect in injection_patterns:
            request = mock_request(query_params={"id": injection_attempt})
    
            if should_detect:
>               with pytest.raises(Exception):  # HTTPException
                     ^^^^^^^^^^^^^^^^^^^^^^^^
E               Failed: DID NOT RAISE <class 'Exception'>

resync\tests\test_database_security.py:291: Failed
------------------------------ Captured log call ------------------------------
WARNING  resync.core.database_security:database_security.py:372 database_security_violation
___________ TestSQLInjectionMiddleware.test_request_data_extraction ___________

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x000002A677E89A70>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_request_data_extraction(self, mock_request):
        """Test request data extraction for analysis."""
        request = mock_request(
            query_params={"id": "123"},
            path_params={"user_id": "456"},
            headers={"User-Agent": "Test Browser"},
            method="POST",
        )
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
        data = asyncio.run(middleware._extract_request_data(request))
    
        assert "query.id" in data
        assert "path.user_id" in data
>       assert "header.User-Agent" in data
E       AssertionError: assert 'header.User-Agent' in {'path.user_id': '456', 'query.id': '123'}

resync\tests\test_database_security.py:331: AssertionError
______ TestAuditRecordValidation.test_validate_audit_record_valid_cases _______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000002A677DDE990>

    def test_validate_audit_record_valid_cases(self):
        """Test valid audit record inputs."""
        valid_records = [
            {
                "id": "test_id_123",
                "user_query": "What is the weather today?",
                "agent_response": "The weather is sunny with a high of 75░F.",
                "ia_audit_reason": None,
                "ia_audit_confidence": None,
            },
            {
                "id": "test_id_456",
                "user_query": "How do I reset my password?",
                "agent_response": "You can reset your password by clicking the forgot password link.",
                "ia_audit_reason": "Suspicious query pattern",
                "ia_audit_confidence": 0.85,
            },
        ]
    
        for record in valid_records:
>           result = _validate_audit_record(record)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

resync\tests\test_database_security.py:372: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

record = {'agent_response': 'The weather is sunny with a high of 75░F.', 'ia_audit_confidence': None, 'ia_audit_reason': None, 'id': 'test_id_123', ...}

    def _validate_audit_record(record: dict) -> bool:
        """Validate an audit record has required fields.
    
        Args:
            record: Audit record dictionary to validate
    
        Returns:
            True if valid
    
        Raises:
            ValueError: If record is invalid
        """
        required_fields = {"action"}
    
        if not isinstance(record, dict):
            raise ValueError("Audit record must be a dictionary")
    
        missing = required_fields - set(record.keys())
        if missing:
>           raise ValueError(f"Missing required fields: {missing}")
E           ValueError: Missing required fields: {'action'}

resync\core\audit_db.py:247: ValueError
_____ TestAuditRecordValidation.test_validate_audit_record_invalid_cases ______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000002A677DDEAD0>

    def test_validate_audit_record_invalid_cases(self):
        """Test invalid audit record inputs."""
        invalid_cases = [
            # Missing required fields
            ({"user_query": "test"}, "Memory ID is required"),
            ({"id": "test"}, "User query is required"),
            ({"id": "test", "user_query": "test"}, "Agent response is required"),
            # Invalid data types
            (
                {"id": 123, "user_query": "test", "agent_response": "response"},
                "Memory ID must be string",
            ),
            (
                {"id": "test", "user_query": None, "agent_response": "response"},
                "User query is required",
            ),
            # Length validation
            (
                {"id": "x" * 256, "user_query": "test", "agent_response": "response"},
                "Memory ID too long",
            ),
            (
                {"id": "test", "user_query": "x" * 10001, "agent_response": "response"},
                "User query too long",
            ),
            # Dangerous content
            (
                {
                    "id": "test",
                    "user_query": "'; DROP TABLE users; --",
                    "agent_response": "response",
                },
                "Dangerous pattern detected",
            ),
        ]
    
        for record, expected_error in invalid_cases:
            with pytest.raises((ValueError, TypeError), match=expected_error):
>               _validate_audit_record(record)

resync\tests\test_database_security.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

record = {'user_query': 'test'}

    def _validate_audit_record(record: dict) -> bool:
        """Validate an audit record has required fields.
    
        Args:
            record: Audit record dictionary to validate
    
        Returns:
            True if valid
    
        Raises:
            ValueError: If record is invalid
        """
        required_fields = {"action"}
    
        if not isinstance(record, dict):
            raise ValueError("Audit record must be a dictionary")
    
        missing = required_fields - set(record.keys())
        if missing:
>           raise ValueError(f"Missing required fields: {missing}")
E           ValueError: Missing required fields: {'action'}

resync\core\audit_db.py:247: ValueError

During handling of the above exception, another exception occurred:

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000002A677DDEAD0>

    def test_validate_audit_record_invalid_cases(self):
        """Test invalid audit record inputs."""
        invalid_cases = [
            # Missing required fields
            ({"user_query": "test"}, "Memory ID is required"),
            ({"id": "test"}, "User query is required"),
            ({"id": "test", "user_query": "test"}, "Agent response is required"),
            # Invalid data types
            (
                {"id": 123, "user_query": "test", "agent_response": "response"},
                "Memory ID must be string",
            ),
            (
                {"id": "test", "user_query": None, "agent_response": "response"},
                "User query is required",
            ),
            # Length validation
            (
                {"id": "x" * 256, "user_query": "test", "agent_response": "response"},
                "Memory ID too long",
            ),
            (
                {"id": "test", "user_query": "x" * 10001, "agent_response": "response"},
                "User query too long",
            ),
            # Dangerous content
            (
                {
                    "id": "test",
                    "user_query": "'; DROP TABLE users; --",
                    "agent_response": "response",
                },
                "Dangerous pattern detected",
            ),
        ]
    
        for record, expected_error in invalid_cases:
>           with pytest.raises((ValueError, TypeError), match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AssertionError: Regex pattern did not match.
E            Regex: 'Memory ID is required'
E            Input: "Missing required fields: {'action'}"

resync\tests\test_database_security.py:414: AssertionError
__________ TestSQLInjectionAttackVectors.test_boolean_based_attacks ___________

self = <resync.tests.test_database_security.TestSQLInjectionAttackVectors object at 0x000002A677DDF110>

    def test_boolean_based_attacks(self):
        """Test boolean-based SQL injection attacks."""
        boolean_attacks = [
            "' OR '1'='1",
            "' OR 'x'='x",
            "') OR ('1'='1' AND ''='",
            "1' AND (SELECT COUNT(*) FROM users) > 0 --",
        ]
    
        for attack in boolean_attacks:
>           with pytest.raises(DatabaseSecurityError):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:483: Failed
_________ TestDatabaseSecurityPerformance.test_middleware_performance _________

self = <resync.tests.test_database_security.TestDatabaseSecurityPerformance object at 0x000002A677DDF390>

    def test_middleware_performance(self):
        """Test that middleware doesn't impact performance significantly."""
        import time
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
    
        # Test large number of requests
        start_time = time.time()
    
        for i in range(1000):
            request_data = {
                "query.id": f"valid_query_{i}",
                "search.term": f"normal_search_term_{i}",
            }
    
            # Simulate the extraction and analysis (without actually processing)
            data = {}
            for key, value in request_data.items():
                data[key] = value
    
            # Check for injection (should be False for all)
>           contains_injection = any(
                pattern.search(str(value)) for pattern in middleware.SQL_INJECTION_PATTERNS
            )

resync\tests\test_database_security.py:566: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

.0 = <list_iterator object at 0x000002A674010B80>

    contains_injection = any(
>       pattern.search(str(value)) for pattern in middleware.SQL_INJECTION_PATTERNS
        ^^^^^^^^^^^^^^
    )
E   AttributeError: 'str' object has no attribute 'search'

resync\tests\test_database_security.py:567: AttributeError
_______________ test_planner_node_creates_plan_for_troubleshoot _______________

    @pytest.mark.asyncio
    async def test_planner_node_creates_plan_for_troubleshoot():
        """Troubleshoot intent should produce collect/analyze/synthesize steps."""
        from resync.core.langgraph.agent_graph import Intent, planner_node
    
        state = {
            "message": "erro no job BATCH_001",
            "intent": Intent.TROUBLESHOOT,
            "entities": {"job_name": "BATCH_001"},
            "execution_plan": None,
            "plan_step_index": 0,
        }
>       result = await planner_node(state)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: object dict can't be used in 'await' expression

resync\tests\test_golden_path_planner.py:156: TypeError
---------------------------- Captured stdout call -----------------------------
2026-02-15 06:10:30 [info     ] planner_created_plan           template=troubleshoot total_steps=3
__________________ test_planner_node_creates_plan_for_action __________________

    @pytest.mark.asyncio
    async def test_planner_node_creates_plan_for_action():
        """Action intent should produce validate/approve/execute/verify steps."""
        from resync.core.langgraph.agent_graph import Intent, planner_node
    
        state = {
            "message": "rerun job TEST",
            "intent": Intent.ACTION,
            "entities": {"job_name": "TEST", "action_type": "rerun"},
            "execution_plan": None,
            "plan_step_index": 0,
        }
>       result = await planner_node(state)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: object dict can't be used in 'await' expression

resync\tests\test_golden_path_planner.py:178: TypeError
---------------------------- Captured stdout call -----------------------------
2026-02-15 06:10:30 [info     ] planner_created_plan           template=action total_steps=4
________________ test_planner_node_bypasses_for_general_intent ________________

    @pytest.mark.asyncio
    async def test_planner_node_bypasses_for_general_intent():
        """General intent should NOT create a plan (direct handler)."""
        from resync.core.langgraph.agent_graph import Intent, planner_node
    
        state = {
            "message": "olß, tudo bem?",
            "intent": Intent.GENERAL,
            "entities": {},
            "execution_plan": None,
            "plan_step_index": 0,
        }
>       result = await planner_node(state)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: object dict can't be used in 'await' expression

resync\tests\test_golden_path_planner.py:198: TypeError
____________________ test_plan_executor_verification_retry ____________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000002A677E33F50>

    @pytest.mark.asyncio
    async def test_plan_executor_verification_retry(monkeypatch):
        """Verify that verify_action can request retry without advancing plan."""
        mock_tws = AsyncMock()
        mock_tws.get_job_status.side_effect = [
            {"status": "UNKNOWN"},
            {"status": "EXECUTING"},
        ]
        mock_tws.execute_action.return_value = {"ok": True}
    
        monkeypatch.setattr("resync.core.factories.get_tws_client_singleton", lambda *a, **k: mock_tws)
        monkeypatch.setattr(asyncio, "sleep", AsyncMock())
    
        from resync.core.langgraph.agent_graph import Intent, plan_executor_node, planner_node
    
        state = {
            "message": "rerun job TEST",
            "intent": Intent.ACTION,
            "entities": {"job_name": "TEST", "action_type": "rerun"},
            "raw_data": {},
            "execution_plan": None,
            "plan_step_index": 0,
            "plan_failed": False,
            "verification_attempts": 0,
            "action_pending_verification": "rerun",
            "max_verification_attempts": 3,
        }
    
>       state = await planner_node(state)
                ^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: object dict can't be used in 'await' expression

resync\tests\test_golden_path_planner.py:407: TypeError
---------------------------- Captured stdout call -----------------------------
2026-02-15 06:10:30 [info     ] planner_created_plan           template=action total_steps=4
_______________ test_lifespan_initializes_app_state_singletons ________________

    def test_lifespan_initializes_app_state_singletons() -> None:
>       app = create_app()
              ^^^^^^^^^^^^

resync\tests\test_lifespan_smoke.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
resync\app_factory.py:675: in create_app
    return ApplicationFactory().create_application()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
resync\app_factory.py:140: in create_application
    self._configure_middleware()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <resync.app_factory.ApplicationFactory object at 0x000002A67EFBDA90>

    def _configure_middleware(self) -> None:
        """Configure all middleware in a safe, production-grade order.
    
        Starlette/FastAPI middleware execution order:
            - The *last* `add_middleware()` call is executed *first* (outermost).
    
        Desired outer-to-inner order:
            1) CorrelationIdMiddleware (sets contextvars for all downstream logs)
            2) Security headers (applied even to CORS preflight)
            3) CSP (production-only)
            4) CORS (proper preflight handling)
            5) Rate limiting (can be bypassed by preflight; intentional)
        """
        from resync.api.middleware.cors_config import CORSConfig
        from resync.api.middleware.cors_middleware import LoggingCORSMiddleware
    
        # 1) Rate limiting (startup-time wiring)
        try:
            from resync.core.security.rate_limiter_v2 import setup_rate_limiting
    
            setup_rate_limiting(self.app)
        except Exception as e:
            # Rate limiting must not silently fail open in production.
            if settings.is_production:
                logger.critical("rate_limiting_setup_failed_prod", error=str(e))
                raise
            logger.warning("rate_limiting_setup_failed", error=str(e))
    
        # 2) CORS configuration (delegate to Starlette CORSMiddleware)
        cors_config = CORSConfig()
        cors_policy = cors_config.get_policy(settings.environment.value)
    
        # Convert list of regex patterns to a single regex string when provided.
        allow_origin_regex = None
        if getattr(cors_policy, "origin_regex_patterns", None):
            allow_origin_regex = "|".join(f"(?:{p})" for p in cors_policy.origin_regex_patterns)
    
        self.app.add_middleware(
            LoggingCORSMiddleware,
            allow_origins=cors_policy.allowed_origins,
            allow_methods=cors_policy.allowed_methods,
            allow_headers=cors_policy.allowed_headers,
            allow_credentials=cors_policy.allow_credentials,
            max_age=cors_policy.max_age,
            allow_origin_regex=allow_origin_regex,
            log_violations=cors_policy.log_violations,
        )
    
        # 3) CSP (production-only)
        if settings.is_production:
            from resync.api.middleware.csp_middleware import CSPMiddleware
    
            self.app.add_middleware(CSPMiddleware, report_only=False)
    
        # 4) Additional security headers
        from resync.config.security import add_additional_security_headers
    
>       add_additional_security_headers(self.app, settings)
E       TypeError: add_additional_security_headers() takes 1 positional argument but 2 were given

resync\app_factory.py:312: TypeError
---------------------------- Captured stdout call -----------------------------
2026-02-15 06:10:30 [info     ] settings_validation_passed
2026-02-15 06:10:30 [warning  ] templates_directory_not_found  path=D:\Python\GITHUB\resync\6.0\templates
2026-02-15 06:10:31 [info     ] Rate limiting enabled          auth_limit=5/minute default_limit=100/minute storage=memory
_____ test_request_scoped_dependency_is_isolated_under_concurrency[trio] ______

asynclib_name = 'trio'

    def get_async_backend(asynclib_name: str | None = None) -> type[AsyncBackend]:
        if asynclib_name is None:
            asynclib_name = sniffio.current_async_library()
    
        # We use our own dict instead of sys.modules to get the already imported back-end
        # class because the appropriate modules in sys.modules could potentially be only
        # partially initialized
        try:
>           return loaded_backends[asynclib_name]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:162: KeyError

During handling of the above exception, another exception occurred:

pyfuncitem = <Function test_request_scoped_dependency_is_isolated_under_concurrency[trio]>

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:
        def run_with_hypothesis(**kwargs: Any) -> None:
            with get_runner(backend_name, backend_options) as runner:
                runner.run_test(original_func, kwargs)
    
        backend = pyfuncitem.funcargs.get("anyio_backend")
        if backend:
            backend_name, backend_options = extract_backend_and_options(backend)
    
            if hasattr(pyfuncitem.obj, "hypothesis"):
                # Wrap the inner test function unless it's already wrapped
                original_func = pyfuncitem.obj.hypothesis.inner_test
                if original_func.__qualname__ != run_with_hypothesis.__qualname__:
                    if iscoroutinefunction(original_func):
                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis
    
                return None
    
            if iscoroutinefunction(pyfuncitem.obj):
                funcargs = pyfuncitem.funcargs
                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>               with get_runner(backend_name, backend_options) as runner:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:43: in get_runner
    asynclib = get_async_backend(backend_name)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:164: in get_async_backend
    module = import_module(f"anyio._backends._{asynclib_name}")
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import annotations
    
    import array
    import math
    import os
    import socket
    import sys
    import types
    import weakref
    from collections.abc import (
        AsyncGenerator,
        AsyncIterator,
        Awaitable,
        Callable,
        Collection,
        Coroutine,
        Iterable,
        Sequence,
    )
    from concurrent.futures import Future
    from contextlib import AbstractContextManager
    from dataclasses import dataclass
    from functools import partial
    from io import IOBase
    from os import PathLike
    from signal import Signals
    from socket import AddressFamily, SocketKind
    from types import TracebackType
    from typing import (
        IO,
        TYPE_CHECKING,
        Any,
        Generic,
        NoReturn,
        TypeVar,
        cast,
        overload,
    )
    
>   import trio.from_thread
E   ModuleNotFoundError: No module named 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_backends\_trio.py:40: ModuleNotFoundError
_________________ test_templates_reference_existing_css_files _________________

    def test_templates_reference_existing_css_files() -> None:
        root = _root()
        templates_dir = root / "templates"
        static_dir = root / "static"
>       assert templates_dir.exists() and templates_dir.is_dir(), "templates/ directory missing"
E       AssertionError: templates/ directory missing
E       assert (False)
E        +  where False = exists()
E        +    where exists = WindowsPath('D:/Python/GITHUB/resync/6.0/templates').exists

resync\tests\test_ui_smoke.py:46: AssertionError
____________________ test_admin_ui_renders_and_serves_css _____________________

    def test_admin_ui_renders_and_serves_css() -> None:
        """Validate that templates render and CSS assets are reachable.
    
        This test has two layers:
        1) Always-run minimal UI check (no external deps) that renders admin.html
           and serves the bundled CSS from /static.
        2) If full runtime dependencies are available (e.g. SQLAlchemy), also
           instantiate the real app and verify the real /admin route.
        """
    
        # ------------------------------------------------------------------
        # Layer 1: Minimal render check (no database/redis required)
        # ------------------------------------------------------------------
        from fastapi import FastAPI
        from fastapi.responses import HTMLResponse
        from fastapi.staticfiles import StaticFiles
        from fastapi.templating import Jinja2Templates
    
        root = _root()
        templates = Jinja2Templates(directory=str(root / "templates"))
        app_min = FastAPI()
>       app_min.mount("/static", StaticFiles(directory=str(root / "static")), name="static")
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

resync\tests\test_ui_smoke.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.staticfiles.StaticFiles object at 0x000002A67FD08980>

    def __init__(
        self,
        *,
        directory: PathLike | None = None,
        packages: list[str | tuple[str, str]] | None = None,
        html: bool = False,
        check_dir: bool = True,
        follow_symlink: bool = False,
    ) -> None:
        self.directory = directory
        self.packages = packages
        self.all_directories = self.get_directories(directory, packages)
        self.html = html
        self.config_checked = False
        self.follow_symlink = follow_symlink
        if check_dir and directory is not None and not os.path.isdir(directory):
>           raise RuntimeError(f"Directory '{directory}' does not exist")
E           RuntimeError: Directory 'D:\Python\GITHUB\resync\6.0\static' does not exist

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\staticfiles.py:56: RuntimeError
============================== warnings summary ===============================
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
  C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic\_internal\_generate_schema.py:298: PydanticDeprecatedSince20: `json_encoders` is deprecated. See https://docs.pydantic.dev/2.11/concepts/serialization/#custom-serializers for alternatives. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_validate_table_name_invalid_cases
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_validate_column_name_invalid_cases
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_validate_string_input_invalid_cases
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_sanitize_query_string
FAILED resync/tests/test_database_security.py::TestSecureQueryBuilder::test_build_select_query_with_where
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_sql_injection_detection_patterns
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_request_data_extraction
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_valid_cases
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_invalid_cases
FAILED resync/tests/test_database_security.py::TestSQLInjectionAttackVectors::test_boolean_based_attacks
FAILED resync/tests/test_database_security.py::TestDatabaseSecurityPerformance::test_middleware_performance
FAILED resync/tests/test_golden_path_planner.py::test_planner_node_creates_plan_for_troubleshoot
FAILED resync/tests/test_golden_path_planner.py::test_planner_node_creates_plan_for_action
FAILED resync/tests/test_golden_path_planner.py::test_planner_node_bypasses_for_general_intent
FAILED resync/tests/test_golden_path_planner.py::test_plan_executor_verification_retry
FAILED resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
FAILED resync/tests/test_request_scope_isolation.py::test_request_scoped_dependency_is_isolated_under_concurrency[trio]
FAILED resync/tests/test_ui_smoke.py::test_templates_reference_existing_css_files
FAILED resync/tests/test_ui_smoke.py::test_admin_ui_renders_and_serves_css - ...
============ 19 failed, 84 passed, 1 skipped, 2 warnings in 23.34s ============
<sys>:0: RuntimeWarning: coroutine 'metrics_collector_loop' was never awaited
