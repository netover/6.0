============================= test session starts =============================
platform win32 -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: D:\Python\GITHUB\resync\6.0
plugins: anyio-4.11.0, hypothesis-6.140.2, locust-2.41.2, asyncio-1.2.0, benchmark-5.1.0, cov-7.0.0, mock-3.15.1, timeout-2.4.0, xdist-3.8.0, respx-0.22.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 104 items

resync\tests\contracts\test_tws_client_contract.py .........             [  8%]
resync\tests\test_app_state_contract.py .                                [  9%]
resync\tests\test_database_security.py .....F....F.F...F.F.FF...F.....   [ 39%]
resync\tests\test_database_url_security.py .......                       [ 46%]
resync\tests\test_golden_path_planner.py ............................... [ 75%]
..............                                                           [ 89%]
resync\tests\test_http_di_canonical.py .                                 [ 90%]
resync\tests\test_lifespan_smoke.py F                                    [ 91%]
resync\tests\test_migrations_integration.py s                            [ 92%]
resync\tests\test_public_dependency_signatures.py .                      [ 93%]
resync\tests\test_request_scope_isolation.py .F                          [ 95%]
resync\tests\test_startup_timeout.py ...                                 [ 98%]
resync\tests\test_ui_smoke.py FF                                         [100%]

================================== FAILURES ===================================
_____ TestDatabaseInputValidator.test_validate_string_input_invalid_cases _____

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x0000029466864F30>

    def test_validate_string_input_invalid_cases(self):
        """Test invalid string inputs."""
        invalid_cases = [
            (None, "String input cannot be None"),
            (123, "Input must be string"),
            ("a" * 10001, "String input too long"),
            ("text with \x00 null byte", "String input cannot contain null bytes"),
            ("'; DROP TABLE users; --", "Dangerous pattern detected"),
            ("' OR '1'='1", "Dangerous pattern detected"),
        ]
    
        for input_text, expected_error in invalid_cases:
>           with pytest.raises(DatabaseSecurityError, match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:113: Failed
____________ TestDatabaseInputValidator.test_sanitize_query_string ____________

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x0000029465A10F50>

    def test_sanitize_query_string(self):
        """Test query string sanitization."""
        test_cases = [
            ("normal query", "normal query"),
            ("query with 'quotes'", "query with ''quotes''"),
            ('query with "quotes"', 'query with ""quotes""'),
            ("query; DROP TABLE users; --", "query DROP TABLE users"),
            ("query with /* comment */ text", "query with comment text"),
        ]
    
        for input_query, expected_output in test_cases:
            result = DatabaseInputValidator.sanitize_query_string(input_query)
>           assert result == expected_output, (
                f"Query sanitization failed: {input_query} -> {result}"
            )
E           AssertionError: Query sanitization failed: query with /* comment */ text -> query with  text
E           assert 'query with  text' == 'query with comment text'
E             
E             - query with comment text
E             ?            -------
E             + query with  text

resync\tests\test_database_security.py:187: AssertionError
__________ TestSecureQueryBuilder.test_build_select_query_with_where __________

self = <resync.tests.test_database_security.TestSecureQueryBuilder object at 0x0000029466565F90>

    def test_build_select_query_with_where(self):
        """Test SELECT query with WHERE clause."""
        query, params = SecureQueryBuilder.build_select_query(
            table="audit_log", where_clause="status = :status", limit=50
        )
    
        expected_query = "SELECT * FROM audit_log WHERE status = ? LIMIT ?"
>       assert query == expected_query
E       AssertionError: assert 'SELECT * FRO...tatus LIMIT ?' == 'SELECT * FRO...s = ? LIMIT ?'
E         
E         - SELECT * FROM audit_log WHERE status = ? LIMIT ?
E         ?                                        ^
E         + SELECT * FROM audit_log WHERE status = :status LIMIT ?
E         ?                                        ^^^^^^^

resync\tests\test_database_security.py:212: AssertionError
______ TestSQLInjectionMiddleware.test_sql_injection_detection_patterns _______

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x00000294665665D0>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_sql_injection_detection_patterns(self, mock_request):
        """Test SQL injection pattern detection."""
        injection_patterns = [
            ("'; DROP TABLE users; --", True),
            ("' OR '1'='1", True),
            ("' UNION SELECT * FROM users --", True),
            ("; EXEC xp_cmdshell('dir') --", True),
            ("'; WAITFOR DELAY '00:00:05' --", True),
            ("' AND 1=CONVERT(int, (SELECT @@version)) --", True),
        ]
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
    
        for injection_attempt, should_detect in injection_patterns:
            request = mock_request(query_params={"id": injection_attempt})
    
            if should_detect:
>               with pytest.raises(Exception):  # HTTPException
                     ^^^^^^^^^^^^^^^^^^^^^^^^
E               Failed: DID NOT RAISE <class 'Exception'>

resync\tests\test_database_security.py:291: Failed
------------------------------ Captured log call ------------------------------
WARNING  resync.core.database_security:database_security.py:373 database_security_violation
___________ TestSQLInjectionMiddleware.test_request_data_extraction ___________

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x000002946683DA70>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_request_data_extraction(self, mock_request):
        """Test request data extraction for analysis."""
        request = mock_request(
            query_params={"id": "123"},
            path_params={"user_id": "456"},
            headers={"User-Agent": "Test Browser"},
            method="POST",
        )
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
        data = asyncio.run(middleware._extract_request_data(request))
    
        assert "query.id" in data
        assert "path.user_id" in data
>       assert "header.user-agent" in data
E       AssertionError: assert 'header.user-agent' in {'path.user_id': '456', 'query.id': '123'}

resync\tests\test_database_security.py:331: AssertionError
______ TestAuditRecordValidation.test_validate_audit_record_valid_cases _______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x0000029466796850>

    def test_validate_audit_record_valid_cases(self):
        """Test valid audit record inputs."""
        valid_records = [
            {
                "id": "test_id_123",
                "user_query": "What is the weather today?",
                "agent_response": "The weather is sunny with a high of 75░F.",
                "ia_audit_reason": None,
                "ia_audit_confidence": None,
                "action": "QUERY",
            },
            {
                "id": "test_id_456",
                "user_query": "How do I reset my password?",
                "agent_response": "You can reset your password by clicking the forgot password link.",
                "ia_audit_reason": "Suspicious query pattern",
                "ia_audit_confidence": 0.85,
                "action": "RESET_PASSWORD",
            },
        ]
    
        for record in valid_records:
            result = _validate_audit_record(record)
>           assert result["id"] == record["id"]
                   ^^^^^^^^^^^^
E           TypeError: 'bool' object is not subscriptable

resync\tests\test_database_security.py:375: TypeError
_____ TestAuditRecordValidation.test_validate_audit_record_invalid_cases ______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x0000029466796990>

    def test_validate_audit_record_invalid_cases(self):
        """Test invalid audit record inputs."""
        invalid_cases = [
            # Missing required fields
            ({"user_query": "test", "action": "TEST"}, "Memory ID is required"),
            ({"id": "test", "action": "TEST"}, "User query is required"),
            ({"id": "test", "user_query": "test", "action": "TEST"}, "Agent response is required"),
            # Invalid data types
            (
                {"id": 123, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID must be string",
            ),
            (
                {"id": "test", "user_query": None, "agent_response": "response", "action": "TEST"},
                "User query is required",
            ),
            # Length validation
            (
                {"id": "x" * 256, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID too long",
            ),
            (
                {"id": "test", "user_query": "x" * 10001, "agent_response": "response", "action": "TEST"},
                "User query too long",
            ),
            # Dangerous content
            (
                {
                    "id": "test",
                    "user_query": "'; DROP TABLE users; --",
                    "agent_response": "response",
                    "action": "TEST",
                },
                "Dangerous pattern detected",
            ),
        ]
    
        for record, expected_error in invalid_cases:
>           with pytest.raises((ValueError, TypeError), match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE any of (<class 'ValueError'>, <class 'TypeError'>)

resync\tests\test_database_security.py:417: Failed
__________ TestSQLInjectionAttackVectors.test_boolean_based_attacks ___________

self = <resync.tests.test_database_security.TestSQLInjectionAttackVectors object at 0x0000029466796FD0>

    def test_boolean_based_attacks(self):
        """Test boolean-based SQL injection attacks."""
        boolean_attacks = [
            "' OR '1'='1",
            "' OR 'x'='x",
            "') OR ('1'='1' AND ''='",
            "1' AND (SELECT COUNT(*) FROM users) > 0 --",
        ]
    
        for attack in boolean_attacks:
>           with pytest.raises(DatabaseSecurityError):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:486: Failed
_______________ test_lifespan_initializes_app_state_singletons ________________

    def test_lifespan_initializes_app_state_singletons() -> None:
>       app = create_app()
              ^^^^^^^^^^^^

resync\tests\test_lifespan_smoke.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
resync\app_factory.py:675: in create_app
    return ApplicationFactory().create_application()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
resync\app_factory.py:143: in create_application
    self._register_routers()
resync\app_factory.py:442: in _register_routers
    from resync.api.routes.core.status import router as status_router
resync\api\routes\core\__init__.py:3: in <module>
    from .chat import router as chat_router
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    """
    Chat routes for FastAPI with RAG integration and Hybrid Agent routing.
    
    v5.4.1 Enhancements (PR-4):
    - HybridRouter with RAG-only, Agentic, and Diagnostic modes
    - Tool execution with guardrails
    - HITL support for write operations
    - Improved intent classification with routing suggestions
    
    v5.4.0 Enhancements:
    - Conversational memory for multi-turn dialogues
    - Hybrid retrieval (BM25 + Vector) for better TWS job search
    - Anaphora resolution ("restart it" -> "restart job AWSBH001")
    
    This module provides the chat API endpoints using the HybridRouter system
    which automatically routes messages to the appropriate handler based on
    intent classification and complexity analysis.
    """
    
    from datetime import datetime, timezone
    
    from fastapi import APIRouter, BackgroundTasks, Depends, Header, HTTPException, status, Request
    
    # v5.4.1: Import HybridRouter (fallback to UnifiedAgent for compatibility)
    try:
        from resync.core.agent_router import HybridRouter, RoutingMode
    
        # v5.7.1 FIX: Import provider to get router with AgentManager
        from resync.core.wiring import get_hybrid_router as get_hybrid_router_provider
    
        _use_hybrid_router = True
    except ImportError:
        from resync.core.agent_manager import unified_agent
    
        _use_hybrid_router = False
    
    # Import RAG components
    # v5.4.0: Import memory system
    from resync.api.dependencies_v2 import get_logger
    from resync.api.models.requests import ChatHistoryQuery, ChatMessageRequest
    from resync.api.models.responses_v2 import ChatMessageResponse
    from resync.core.memory import ConversationContext, get_conversation_memory
    from resync.knowledge.ingestion.embedding_service import EmbeddingService
    from resync.knowledge.ingestion.ingest import IngestService
    from resync.knowledge.retrieval.retriever import RagRetriever
    from resync.knowledge.store.pgvector_store import get_vector_store
    
    router = APIRouter()
    logger = None  # Will be injected by dependency
    
    # v5.4.1: HybridRouter instance (singleton)
    _hybrid_router: HybridRouter | None = None
    
    # RAG components will be initialized lazily (when first used)
    # to avoid event loop issues during module import
    _rag_initialized = False
    _rag_embedding_service = None
    _rag_vector_store = None
    _rag_retriever = None
    _rag_ingest_service = None
    
    # v5.4.0: Hybrid retriever (lazy loaded)
    _hybrid_retriever = None
    
    
    async def _get_rag_components():
        """Lazy initialization of RAG components within async context"""
        global \
            _rag_initialized, \
            _rag_embedding_service, \
            _rag_vector_store, \
            _rag_retriever, \
            _rag_ingest_service, \
            _hybrid_retriever
    
        if not _rag_initialized:
            try:
                _rag_embedding_service = EmbeddingService()
                _rag_vector_store = await get_vector_store()
                _rag_retriever = RagRetriever(_rag_embedding_service, _rag_vector_store)
                _rag_ingest_service = IngestService(_rag_embedding_service, _rag_vector_store)
    
                # v5.4.0: Initialize hybrid retriever
                try:
                    from resync.knowledge.retrieval.hybrid_retriever import HybridRetriever
    
                    _hybrid_retriever = HybridRetriever(_rag_embedding_service, _rag_vector_store)
                    if logger:
                        logger.info("Hybrid retriever initialized (BM25 + Vector)")
                except Exception as e:
                    if logger:
                        logger.warning("Hybrid retriever not available, using standard: %s", e)
    
                _rag_initialized = True
                if logger:
                    logger.info("RAG components initialized successfully (lazy)")
            except Exception as e:
                if logger:
                    logger.error("Failed to initialize RAG components: %s", e)
                _rag_embedding_service = None
                _rag_vector_store = None
                _rag_retriever = None
                _rag_ingest_service = None
    
        return _rag_embedding_service, _rag_vector_store, _rag_retriever, _rag_ingest_service
    
    
    async def _get_or_create_session(session_id: str | None) -> ConversationContext:
        """Get or create conversation session for memory."""
        memory = get_conversation_memory()
        return await memory.get_or_create_session(session_id)
    
    
    async def _save_conversation_turn(
        session_id: str,
        user_message: str,
        assistant_response: str,
        metadata: dict | None = None,
    ) -> None:
        """Save conversation turn to memory."""
        try:
            memory = get_conversation_memory()
            await memory.add_turn(session_id, user_message, assistant_response, metadata)
        except Exception as e:
            # Re-raise programming errors ù these are bugs, not runtime failures
            if isinstance(e, (TypeError, KeyError, AttributeError, IndexError)):
                raise
            if logger:
                logger.warning("Failed to save conversation turn: %s", e)
    
    
    @router.post("/chat", response_model=ChatMessageResponse)
    async def chat_message(
        request: ChatMessageRequest,
        background_tasks: BackgroundTasks,
        x_session_id: str | None = Header(None, alias="X-Session-ID"),
        x_routing_mode: str | None = Header(None, alias="X-Routing-Mode"),
        # Temporarily disabled authentication for testing
>       current_user: dict | None = Depends(get_current_user),
                                            ^^^^^^^^^^^^^^^^
        hybrid_router=Depends(get_hybrid_router_provider),
        logger_instance=Depends(get_logger),
    ):
E   NameError: name 'get_current_user' is not defined

resync\api\routes\core\chat.py:139: NameError
---------------------------- Captured stdout call -----------------------------
2026-02-15 06:16:01 [info     ] settings_validation_passed
2026-02-15 06:16:01 [warning  ] templates_directory_not_found  path=D:\Python\GITHUB\resync\6.0\templates
2026-02-15 06:16:01 [info     ] Rate limiting enabled          auth_limit=5/minute default_limit=100/minute storage=memory
2026-02-15 06:16:01 [info     ] middleware_configured
2026-02-15 06:16:01 [info     ] Exception handlers registered successfully
2026-02-15 06:16:01 [info     ] exception_handlers_registered
2026-02-15 06:16:01 [info     ] dependency_injection_configured mode=fastapi_depends
2026-02-15 06:16:01 [info     ] enhanced_endpoints_registered  prefix=/api/v2
2026-02-15 06:16:01 [info     ] graphrag_admin_endpoints_registered prefix=/api/admin/graphrag
2026-02-15 06:16:01 [info     ] document_kg_admin_endpoints_registered prefix=/api/admin/kg
2026-02-15 06:16:01 [info     ] unified_config_endpoints_registered prefix=/api/admin/config
2026-02-15 06:16:02 [warning  ] templates_directory_not_found
2026-02-15 06:16:02 [info     ] monitoring_routers_registered
------------------------------ Captured log call ------------------------------
WARNING  resync.api.auth.service:service.py:23 AUTH_SECRET_KEY not set ù using insecure default. This is only acceptable in development.
_____ test_request_scoped_dependency_is_isolated_under_concurrency[trio] ______

asynclib_name = 'trio'

    def get_async_backend(asynclib_name: str | None = None) -> type[AsyncBackend]:
        if asynclib_name is None:
            asynclib_name = sniffio.current_async_library()
    
        # We use our own dict instead of sys.modules to get the already imported back-end
        # class because the appropriate modules in sys.modules could potentially be only
        # partially initialized
        try:
>           return loaded_backends[asynclib_name]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:162: KeyError

During handling of the above exception, another exception occurred:

pyfuncitem = <Function test_request_scoped_dependency_is_isolated_under_concurrency[trio]>

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:
        def run_with_hypothesis(**kwargs: Any) -> None:
            with get_runner(backend_name, backend_options) as runner:
                runner.run_test(original_func, kwargs)
    
        backend = pyfuncitem.funcargs.get("anyio_backend")
        if backend:
            backend_name, backend_options = extract_backend_and_options(backend)
    
            if hasattr(pyfuncitem.obj, "hypothesis"):
                # Wrap the inner test function unless it's already wrapped
                original_func = pyfuncitem.obj.hypothesis.inner_test
                if original_func.__qualname__ != run_with_hypothesis.__qualname__:
                    if iscoroutinefunction(original_func):
                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis
    
                return None
    
            if iscoroutinefunction(pyfuncitem.obj):
                funcargs = pyfuncitem.funcargs
                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>               with get_runner(backend_name, backend_options) as runner:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:43: in get_runner
    asynclib = get_async_backend(backend_name)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:164: in get_async_backend
    module = import_module(f"anyio._backends._{asynclib_name}")
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import annotations
    
    import array
    import math
    import os
    import socket
    import sys
    import types
    import weakref
    from collections.abc import (
        AsyncGenerator,
        AsyncIterator,
        Awaitable,
        Callable,
        Collection,
        Coroutine,
        Iterable,
        Sequence,
    )
    from concurrent.futures import Future
    from contextlib import AbstractContextManager
    from dataclasses import dataclass
    from functools import partial
    from io import IOBase
    from os import PathLike
    from signal import Signals
    from socket import AddressFamily, SocketKind
    from types import TracebackType
    from typing import (
        IO,
        TYPE_CHECKING,
        Any,
        Generic,
        NoReturn,
        TypeVar,
        cast,
        overload,
    )
    
>   import trio.from_thread
E   ModuleNotFoundError: No module named 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_backends\_trio.py:40: ModuleNotFoundError
_________________ test_templates_reference_existing_css_files _________________

    def test_templates_reference_existing_css_files() -> None:
        root = _root()
        templates_dir = root / "templates"
        static_dir = root / "static"
>       assert templates_dir.exists() and templates_dir.is_dir(), "templates/ directory missing"
E       AssertionError: templates/ directory missing
E       assert (False)
E        +  where False = exists()
E        +    where exists = WindowsPath('D:/Python/GITHUB/resync/6.0/templates').exists

resync\tests\test_ui_smoke.py:46: AssertionError
____________________ test_admin_ui_renders_and_serves_css _____________________

    def test_admin_ui_renders_and_serves_css() -> None:
        """Validate that templates render and CSS assets are reachable.
    
        This test has two layers:
        1) Always-run minimal UI check (no external deps) that renders admin.html
           and serves the bundled CSS from /static.
        2) If full runtime dependencies are available (e.g. SQLAlchemy), also
           instantiate the real app and verify the real /admin route.
        """
    
        # ------------------------------------------------------------------
        # Layer 1: Minimal render check (no database/redis required)
        # ------------------------------------------------------------------
        from fastapi import FastAPI
        from fastapi.responses import HTMLResponse
        from fastapi.staticfiles import StaticFiles
        from fastapi.templating import Jinja2Templates
    
        root = _root()
        templates = Jinja2Templates(directory=str(root / "templates"))
        app_min = FastAPI()
>       app_min.mount("/static", StaticFiles(directory=str(root / "static")), name="static")
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

resync\tests\test_ui_smoke.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.staticfiles.StaticFiles object at 0x000002945DFFACF0>

    def __init__(
        self,
        *,
        directory: PathLike | None = None,
        packages: list[str | tuple[str, str]] | None = None,
        html: bool = False,
        check_dir: bool = True,
        follow_symlink: bool = False,
    ) -> None:
        self.directory = directory
        self.packages = packages
        self.all_directories = self.get_directories(directory, packages)
        self.html = html
        self.config_checked = False
        self.follow_symlink = follow_symlink
        if check_dir and directory is not None and not os.path.isdir(directory):
>           raise RuntimeError(f"Directory '{directory}' does not exist")
E           RuntimeError: Directory 'D:\Python\GITHUB\resync\6.0\static' does not exist

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\staticfiles.py:56: RuntimeError
============================== warnings summary ===============================
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
  C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic\_internal\_generate_schema.py:298: PydanticDeprecatedSince20: `json_encoders` is deprecated. See https://docs.pydantic.dev/2.11/concepts/serialization/#custom-serializers for alternatives. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\core\database\models\teams.py:8: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\api\health.py:10: DeprecationWarning: Importing 'get_health_check_service' from 'resync.core.health' is deprecated. Use 'get_unified_health_service' instead.
    from resync.core.health import (

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\api\routes\monitoring\dashboard.py:462: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @router.on_event("startup")

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\core\database\models\teams_notifications.py:8: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_validate_string_input_invalid_cases
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_sanitize_query_string
FAILED resync/tests/test_database_security.py::TestSecureQueryBuilder::test_build_select_query_with_where
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_sql_injection_detection_patterns
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_request_data_extraction
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_valid_cases
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_invalid_cases
FAILED resync/tests/test_database_security.py::TestSQLInjectionAttackVectors::test_boolean_based_attacks
FAILED resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
FAILED resync/tests/test_request_scope_isolation.py::test_request_scoped_dependency_is_isolated_under_concurrency[trio]
FAILED resync/tests/test_ui_smoke.py::test_templates_reference_existing_css_files
FAILED resync/tests/test_ui_smoke.py::test_admin_ui_renders_and_serves_css - ...
============ 12 failed, 91 passed, 1 skipped, 6 warnings in 57.88s ============
<sys>:0: RuntimeWarning: coroutine 'metrics_collector_loop' was never awaited
