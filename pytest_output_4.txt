============================= test session starts =============================
platform win32 -- Python 3.13.7, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: D:\Python\GITHUB\resync\6.0
plugins: anyio-4.11.0, hypothesis-6.140.2, locust-2.41.2, asyncio-1.2.0, benchmark-5.1.0, cov-7.0.0, mock-3.15.1, timeout-2.4.0, xdist-3.8.0, respx-0.22.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 104 items

resync\tests\contracts\test_tws_client_contract.py .........             [  8%]
resync\tests\test_app_state_contract.py .                                [  9%]
resync\tests\test_database_security.py .....F..........F.F.FF...F.....   [ 39%]
resync\tests\test_database_url_security.py .......                       [ 46%]
resync\tests\test_golden_path_planner.py ............................... [ 75%]
..............                                                           [ 89%]
resync\tests\test_http_di_canonical.py .                                 [ 90%]
resync\tests\test_lifespan_smoke.py .                                    [ 91%]
resync\tests\test_migrations_integration.py s                            [ 92%]
resync\tests\test_public_dependency_signatures.py .                      [ 93%]
resync\tests\test_request_scope_isolation.py .F                          [ 95%]
resync\tests\test_startup_timeout.py ...                                 [ 98%]
resync\tests\test_ui_smoke.py FF                                         [100%]

================================== FAILURES ===================================
_____ TestDatabaseInputValidator.test_validate_string_input_invalid_cases _____

self = <resync.tests.test_database_security.TestDatabaseInputValidator object at 0x000001C3ED448F30>

    def test_validate_string_input_invalid_cases(self):
        """Test invalid string inputs."""
        invalid_cases = [
            (None, "String input cannot be None"),
            (123, "Input must be string"),
            ("a" * 10001, "String input too long"),
            ("text with \x00 null byte", "String input cannot contain null bytes"),
            ("'; DROP TABLE users; --", "Dangerous pattern detected"),
            ("' OR '1'='1", "Dangerous pattern detected"),
        ]
    
        for input_text, expected_error in invalid_cases:
>           with pytest.raises(DatabaseSecurityError, match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:113: Failed
______ TestSQLInjectionMiddleware.test_sql_injection_detection_patterns _______

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x000001C3ED1425D0>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_sql_injection_detection_patterns(self, mock_request):
        """Test SQL injection pattern detection."""
        injection_patterns = [
            ("'; DROP TABLE users; --", True),
            ("' OR '1'='1", True),
            ("' UNION SELECT * FROM users --", True),
            ("; EXEC xp_cmdshell('dir') --", True),
            ("'; WAITFOR DELAY '00:00:05' --", True),
            ("' AND 1=CONVERT(int, (SELECT @@version)) --", True),
        ]
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
    
        for injection_attempt, should_detect in injection_patterns:
            request = mock_request(query_params={"id": injection_attempt})
    
            if should_detect:
>               with pytest.raises(Exception):  # HTTPException
                     ^^^^^^^^^^^^^^^^^^^^^^^^
E               Failed: DID NOT RAISE <class 'Exception'>

resync\tests\test_database_security.py:291: Failed
------------------------------ Captured log call ------------------------------
WARNING  resync.core.database_security:database_security.py:373 database_security_violation
___________ TestSQLInjectionMiddleware.test_request_data_extraction ___________

self = <resync.tests.test_database_security.TestSQLInjectionMiddleware object at 0x000001C3ED421BA0>
mock_request = <class 'resync.tests.test_database_security.TestSQLInjectionMiddleware.mock_request.<locals>.MockRequest'>

    def test_request_data_extraction(self, mock_request):
        """Test request data extraction for analysis."""
        request = mock_request(
            query_params={"id": "123"},
            path_params={"user_id": "456"},
            headers={"User-Agent": "Test Browser"},
            method="POST",
        )
    
        middleware = DatabaseSecurityMiddleware(None, enabled=True)
        data = asyncio.run(middleware._extract_request_data(request))
    
        assert "query.id" in data
        assert "path.user_id" in data
>       assert "header.user-agent" in data
E       AssertionError: assert 'header.user-agent' in {'path.user_id': '456', 'query.id': '123'}

resync\tests\test_database_security.py:331: AssertionError
______ TestAuditRecordValidation.test_validate_audit_record_valid_cases _______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000001C3ED37A850>

    def test_validate_audit_record_valid_cases(self):
        """Test valid audit record inputs."""
        valid_records = [
            {
                "id": "test_id_123",
                "user_query": "What is the weather today?",
                "agent_response": "The weather is sunny with a high of 75â–‘F.",
                "ia_audit_reason": None,
                "ia_audit_confidence": None,
                "action": "QUERY",
            },
            {
                "id": "test_id_456",
                "user_query": "How do I reset my password?",
                "agent_response": "You can reset your password by clicking the forgot password link.",
                "ia_audit_reason": "Suspicious query pattern",
                "ia_audit_confidence": 0.85,
                "action": "RESET_PASSWORD",
            },
        ]
    
        for record in valid_records:
            result = _validate_audit_record(record)
            assert result is True
>           assert result["user_query"] == record["user_query"]
                   ^^^^^^^^^^^^^^^^^^^^
E           TypeError: 'bool' object is not subscriptable

resync\tests\test_database_security.py:376: TypeError
_____ TestAuditRecordValidation.test_validate_audit_record_invalid_cases ______

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000001C3ED37A990>

    def test_validate_audit_record_invalid_cases(self):
        """Test invalid audit record inputs."""
        invalid_cases = [
            # Missing required fields
            ({"user_query": "test", "action": "TEST"}, "Memory ID is required"),
            ({"id": "test", "action": "TEST"}, "User query is required"),
            ({"id": "test", "user_query": "test", "action": "TEST"}, "Agent response is required"),
            # Invalid data types
            (
                {"id": 123, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID must be string",
            ),
            (
                {"id": "test", "user_query": None, "agent_response": "response", "action": "TEST"},
                "User query is required",
            ),
            # Length validation
            (
                {"id": "x" * 256, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID too long",
            ),
            (
                {"id": "test", "user_query": "x" * 10001, "agent_response": "response", "action": "TEST"},
                "User query too long",
            ),
            # Dangerous content
            (
                {
                    "id": "test",
                    "user_query": "'; DROP TABLE users; --",
                    "agent_response": "response",
                    "action": "TEST",
                },
                "Dangerous pattern detected",
            ),
        ]
    
        for record, expected_error in invalid_cases:
            with pytest.raises((ValueError, TypeError), match=expected_error):
>               _validate_audit_record(record)

resync\tests\test_database_security.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

record = {'action': 'TEST', 'user_query': 'test'}

    def _validate_audit_record(record: dict) -> bool:
        """Validate an audit record has required fields.
    
        Args:
            record: Audit record dictionary to validate
    
        Returns:
            True if valid
    
        Raises:
            ValueError: If record is invalid
        """
        required_fields = {"action"}
    
        if not isinstance(record, dict):
            raise ValueError("Audit record must be a dictionary")
    
        missing = required_fields - set(record.keys())
        if missing:
            raise ValueError(f"Missing required fields: {missing}")
    
        if not record.get("action"):
            raise ValueError("Action field cannot be empty")
    
        # Loose validation for id (Memory ID) if present
        if "id" in record:
             if not isinstance(record["id"], str):
                 raise ValueError("Memory ID must be string")
             if len(record["id"]) > 255:
                 raise ValueError("Memory ID too long")
    
        # Loose validation for user_query if present
        if "user_query" in record:
             if not isinstance(record["user_query"], str):
                 raise ValueError("User query must be string")
             if len(record["user_query"]) > 10000:
                 raise ValueError("User query too long")
             if not record["user_query"]:
                 raise ValueError("User query cannot be empty")
    
        # Loose validation for agent_response if present in valid cases
        # The test expects it to be required for the test cases provided
        if "agent_response" not in record and "user_query" in record:
>            raise ValueError("Agent response is required")
E            ValueError: Agent response is required

resync\core\audit_db.py:271: ValueError

During handling of the above exception, another exception occurred:

self = <resync.tests.test_database_security.TestAuditRecordValidation object at 0x000001C3ED37A990>

    def test_validate_audit_record_invalid_cases(self):
        """Test invalid audit record inputs."""
        invalid_cases = [
            # Missing required fields
            ({"user_query": "test", "action": "TEST"}, "Memory ID is required"),
            ({"id": "test", "action": "TEST"}, "User query is required"),
            ({"id": "test", "user_query": "test", "action": "TEST"}, "Agent response is required"),
            # Invalid data types
            (
                {"id": 123, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID must be string",
            ),
            (
                {"id": "test", "user_query": None, "agent_response": "response", "action": "TEST"},
                "User query is required",
            ),
            # Length validation
            (
                {"id": "x" * 256, "user_query": "test", "agent_response": "response", "action": "TEST"},
                "Memory ID too long",
            ),
            (
                {"id": "test", "user_query": "x" * 10001, "agent_response": "response", "action": "TEST"},
                "User query too long",
            ),
            # Dangerous content
            (
                {
                    "id": "test",
                    "user_query": "'; DROP TABLE users; --",
                    "agent_response": "response",
                    "action": "TEST",
                },
                "Dangerous pattern detected",
            ),
        ]
    
        for record, expected_error in invalid_cases:
>           with pytest.raises((ValueError, TypeError), match=expected_error):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           AssertionError: Regex pattern did not match.
E            Regex: 'Memory ID is required'
E            Input: 'Agent response is required'

resync\tests\test_database_security.py:417: AssertionError
__________ TestSQLInjectionAttackVectors.test_boolean_based_attacks ___________

self = <resync.tests.test_database_security.TestSQLInjectionAttackVectors object at 0x000001C3ED37AFD0>

    def test_boolean_based_attacks(self):
        """Test boolean-based SQL injection attacks."""
        boolean_attacks = [
            "' OR '1'='1",
            "' OR 'x'='x",
            "') OR ('1'='1' AND ''='",
            "1' AND (SELECT COUNT(*) FROM users) > 0 --",
        ]
    
        for attack in boolean_attacks:
>           with pytest.raises(DatabaseSecurityError):
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           Failed: DID NOT RAISE <class 'resync.core.database_security.DatabaseSecurityError'>

resync\tests\test_database_security.py:486: Failed
_____ test_request_scoped_dependency_is_isolated_under_concurrency[trio] ______

asynclib_name = 'trio'

    def get_async_backend(asynclib_name: str | None = None) -> type[AsyncBackend]:
        if asynclib_name is None:
            asynclib_name = sniffio.current_async_library()
    
        # We use our own dict instead of sys.modules to get the already imported back-end
        # class because the appropriate modules in sys.modules could potentially be only
        # partially initialized
        try:
>           return loaded_backends[asynclib_name]
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           KeyError: 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:162: KeyError

During handling of the above exception, another exception occurred:

pyfuncitem = <Function test_request_scoped_dependency_is_isolated_under_concurrency[trio]>

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:
        def run_with_hypothesis(**kwargs: Any) -> None:
            with get_runner(backend_name, backend_options) as runner:
                runner.run_test(original_func, kwargs)
    
        backend = pyfuncitem.funcargs.get("anyio_backend")
        if backend:
            backend_name, backend_options = extract_backend_and_options(backend)
    
            if hasattr(pyfuncitem.obj, "hypothesis"):
                # Wrap the inner test function unless it's already wrapped
                original_func = pyfuncitem.obj.hypothesis.inner_test
                if original_func.__qualname__ != run_with_hypothesis.__qualname__:
                    if iscoroutinefunction(original_func):
                        pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis
    
                return None
    
            if iscoroutinefunction(pyfuncitem.obj):
                funcargs = pyfuncitem.funcargs
                testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
>               with get_runner(backend_name, backend_options) as runner:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\pytest_plugin.py:43: in get_runner
    asynclib = get_async_backend(backend_name)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_core\_eventloop.py:164: in get_async_backend
    module = import_module(f"anyio._backends._{asynclib_name}")
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\importlib\__init__.py:88: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    from __future__ import annotations
    
    import array
    import math
    import os
    import socket
    import sys
    import types
    import weakref
    from collections.abc import (
        AsyncGenerator,
        AsyncIterator,
        Awaitable,
        Callable,
        Collection,
        Coroutine,
        Iterable,
        Sequence,
    )
    from concurrent.futures import Future
    from contextlib import AbstractContextManager
    from dataclasses import dataclass
    from functools import partial
    from io import IOBase
    from os import PathLike
    from signal import Signals
    from socket import AddressFamily, SocketKind
    from types import TracebackType
    from typing import (
        IO,
        TYPE_CHECKING,
        Any,
        Generic,
        NoReturn,
        TypeVar,
        cast,
        overload,
    )
    
>   import trio.from_thread
E   ModuleNotFoundError: No module named 'trio'

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\anyio\_backends\_trio.py:40: ModuleNotFoundError
_________________ test_templates_reference_existing_css_files _________________

    def test_templates_reference_existing_css_files() -> None:
        root = _root()
        templates_dir = root / "templates"
        static_dir = root / "static"
>       assert templates_dir.exists() and templates_dir.is_dir(), "templates/ directory missing"
E       AssertionError: templates/ directory missing
E       assert (False)
E        +  where False = exists()
E        +    where exists = WindowsPath('D:/Python/GITHUB/resync/6.0/resync/templates').exists

resync\tests\test_ui_smoke.py:46: AssertionError
____________________ test_admin_ui_renders_and_serves_css _____________________

    def test_admin_ui_renders_and_serves_css() -> None:
        """Validate that templates render and CSS assets are reachable.
    
        This test has two layers:
        1) Always-run minimal UI check (no external deps) that renders admin.html
           and serves the bundled CSS from /static.
        2) If full runtime dependencies are available (e.g. SQLAlchemy), also
           instantiate the real app and verify the real /admin route.
        """
    
        # ------------------------------------------------------------------
        # Layer 1: Minimal render check (no database/redis required)
        # ------------------------------------------------------------------
        from fastapi import FastAPI
        from fastapi.responses import HTMLResponse
        from fastapi.staticfiles import StaticFiles
        from fastapi.templating import Jinja2Templates
    
        root = _root()
        templates = Jinja2Templates(directory=str(root / "templates"))
        app_min = FastAPI()
>       app_min.mount("/static", StaticFiles(directory=str(root / "static")), name="static")
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

resync\tests\test_ui_smoke.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <starlette.staticfiles.StaticFiles object at 0x000001C3EEAD1FD0>

    def __init__(
        self,
        *,
        directory: PathLike | None = None,
        packages: list[str | tuple[str, str]] | None = None,
        html: bool = False,
        check_dir: bool = True,
        follow_symlink: bool = False,
    ) -> None:
        self.directory = directory
        self.packages = packages
        self.all_directories = self.get_directories(directory, packages)
        self.html = html
        self.config_checked = False
        self.follow_symlink = follow_symlink
        if check_dir and directory is not None and not os.path.isdir(directory):
>           raise RuntimeError(f"Directory '{directory}' does not exist")
E           RuntimeError: Directory 'D:\Python\GITHUB\resync\6.0\resync\static' does not exist

C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\starlette\staticfiles.py:56: RuntimeError
============================== warnings summary ===============================
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
resync/tests/test_golden_path_planner.py::test_router_resets_transient_state
  C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\site-packages\pydantic\_internal\_generate_schema.py:298: PydanticDeprecatedSince20: `json_encoders` is deprecated. See https://docs.pydantic.dev/2.11/concepts/serialization/#custom-serializers for alternatives. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\core\database\models\teams.py:8: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\api\health.py:10: DeprecationWarning: Importing 'get_health_check_service' from 'resync.core.health' is deprecated. Use 'get_unified_health_service' instead.
    from resync.core.health import (

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\api\routes\monitoring\dashboard.py:462: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @router.on_event("startup")

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\core\database\models\teams_notifications.py:8: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

resync/tests/test_lifespan_smoke.py::test_lifespan_initializes_app_state_singletons
  D:\Python\GITHUB\resync\6.0\resync\api\routes\core\health.py:621: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
          
    @router.on_event("shutdown")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED resync/tests/test_database_security.py::TestDatabaseInputValidator::test_validate_string_input_invalid_cases
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_sql_injection_detection_patterns
FAILED resync/tests/test_database_security.py::TestSQLInjectionMiddleware::test_request_data_extraction
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_valid_cases
FAILED resync/tests/test_database_security.py::TestAuditRecordValidation::test_validate_audit_record_invalid_cases
FAILED resync/tests/test_database_security.py::TestSQLInjectionAttackVectors::test_boolean_based_attacks
FAILED resync/tests/test_request_scope_isolation.py::test_request_scoped_dependency_is_isolated_under_concurrency[trio]
FAILED resync/tests/test_ui_smoke.py::test_templates_reference_existing_css_files
FAILED resync/tests/test_ui_smoke.py::test_admin_ui_renders_and_serves_css - ...
========================== warnings summary (final) ===========================
C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\collections\__init__.py:461
  C:\Users\User\AppData\Local\Programs\Python\Python313\Lib\collections\__init__.py:461: RuntimeWarning: coroutine 'metrics_collector_loop' was never awaited
    result = self._make(_map(kwds.pop, field_names, self))
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============ 9 failed, 94 passed, 1 skipped, 8 warnings in 30.26s =============
